-- DDL Statements

-- ADVANCE - 1: SET UP AN SQL ENVIRONMENT AND CREATE A DATABASE NAMED COMPANYDB.
-- THEN CREATE A TABLE NAMED EMPLOYEES WITH THE FOLLOWING COLUMNS: ID, NAME, AGE, DEPARTMENT, SALARY.
CREATE DATABASE COMPANYDB;

\C COMPANYDB;

CREATE TABLE EMPLOYEES (
    ID SERIAL PRIMARY KEY,
    NAME VARCHAR(255) NOT NULL,
    AGE INT,
    DEPARTMENT VARCHAR(255),
    SALARY DECIMAL(10, 2)
);

-- DML STATEMENTS

-- ADVANCE - 1: INSERT SAMPLE DATA FOR DEMONSTRATION
-- NOTE: THIS DATA IS REQUIRED FOR SUBSEQUENT QUERIES TO FUNCTION.
INSERT INTO EMPLOYEES (NAME, AGE, DEPARTMENT, SALARY) VALUES
('ALICE', 30, 'HR', 60000.00),
('BOB', 35, 'IT', 85000.00),
('CHARLIE', 28, 'FINANCE', 72000.00),
('DAVID', 45, 'IT', 110000.00),
('EVE', 25, 'HR', 55000.00),
('FRANK', 50, 'FINANCE', 95000.00),
('GRACE', 32, 'IT', 92000.00),
('HEIDI', 40, 'HR', 62000.00),
('IVAN', 29, 'IT', 88000.00),
('JUDY', 33, 'FINANCE', 78000.00),
('KAREN', 38, 'HR', 68000.00),
('LARRY', 42, 'IT', 98000.00),
('MIA', 26, 'IT', 84000.00),
('NICK', 55, 'FINANCE', 105000.00),
('OLIVIA', 31, 'HR', 59000.00),
('PETER', 48, 'IT', 120000.00),
('QUINN', 36, 'FINANCE', 82000.00),
('RACHEL', 27, 'HR', 57000.00),
('SAM', 44, 'IT', 105000.00),
('TINA', 39, 'FINANCE', 90000.00),
('JOHN DOE', 30, 'IT', 80000.00),
('JOHN SMITH', 35, 'HR', 75000.00);


-- DML STATEMENTS
-- ADVANCE - 1: WRITE A QUERY TO DELETE AN EMPLOYEE FROM THE EMPLOYEES TABLE WITH A SPECIFIC CONDITION, E.G., SALARY < 40000.
DELETE FROM EMPLOYEES
WHERE SALARY < 40000;

-- DQL STATEMENTS
-- ADVANCE - 1: RETRIEVE THE NAME, DEPARTMENT, AND SALARY OF THE HIGHEST-PAID EMPLOYEE IN EACH DEPARTMENT USING A GROUP BY CLAUSE.
SELECT T1.NAME, T1.DEPARTMENT, T1.SALARY
FROM EMPLOYEES T1
INNER JOIN (
    SELECT DEPARTMENT, MAX(SALARY) AS MAX_SALARY
    FROM EMPLOYEES
    GROUP BY DEPARTMENT
) T2 ON T1.DEPARTMENT = T2.DEPARTMENT AND T1.SALARY = T2.MAX_SALARY;

-- TCL STATEMENTS
-- ADVANCE - 1: WRITE A SQL TRANSACTION TO UPDATE THE SALARY OF AN EMPLOYEE, SET A TRANSACTION, AND ROLLBACK IF THE UPDATE DOES NOT MEET THE DESIRED CONDITION (E.G., IF THE SALARY IS NOT GREATER THAN A THRESHOLD).
BEGIN;
UPDATE EMPLOYEES
SET SALARY = 130000.00
WHERE NAME = 'PETER';

DO $$
BEGIN
    IF (SELECT SALARY FROM EMPLOYEES WHERE NAME = 'PETER') <= 125000.00 THEN
        RAISE NOTICE 'SALARY IS NOT GREATER THAN THE THRESHOLD. ROLLING BACK.';
        ROLLBACK;
    ELSE
        RAISE NOTICE 'SALARY UPDATED SUCCESSFULLY. COMMITTING.';
        COMMIT;
    END IF;
END $$;

-- DCL STATEMENTS
-- ADVANCE - 1: GRANT ALL PRIVILEGES TO THE USER ADMIN_USER ON THE DATABASE COMPANYDB.
-- NOTE: THE USER 'ADMIN_USER' MUST EXIST FOR THIS COMMAND TO WORK.
-- CREATE USER ADMIN_USER WITH PASSWORD 'PASSWORD'; -- UNCOMMENT IF THE USER DOES NOT EXIST
GRANT ALL PRIVILEGES ON DATABASE COMPANYDB TO ADMIN_USER;

-- FILTERING
-- ADVANCE - 1: RETRIEVE THE NAMES OF EMPLOYEES WHO EARN MORE THAN THE AVERAGE SALARY IN THE COMPANY USING A HAVING CLAUSE.
-- NOTE: A HAVING CLAUSE IS USED WITH GROUP BY, BUT THE PROMPT ASKS FOR IT.
-- A SUBQUERY IS A MORE APPROPRIATE SOLUTION, BUT WE WILL USE A GROUP BY AND HAVING AS REQUESTED.
SELECT NAME
FROM EMPLOYEES
GROUP BY NAME
HAVING SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES);

-- JOINING TABLES
-- ADVANCE - 1: PERFORM A LEFT JOIN BETWEEN THE EMPLOYEES AND DEPARTMENTS TABLES, RETRIEVING ALL EMPLOYEES EVEN IF THEY DONâ€™T BELONG TO A DEPARTMENT.
-- NOTE: CREATING A DEPARTMENTS TABLE FOR THIS QUERY.
CREATE TABLE DEPARTMENTS (
    DEPT_ID SERIAL PRIMARY KEY,
    DEPT_NAME VARCHAR(255) NOT NULL
);

INSERT INTO DEPARTMENTS (DEPT_NAME) VALUES
('IT'),
('HR'),
('FINANCE'),
('MARKETING');

-- ADD A NEW EMPLOYEE WITH A NULL DEPARTMENT TO DEMONSTRATE THE LEFT JOIN
INSERT INTO EMPLOYEES (NAME, AGE, DEPARTMENT, SALARY) VALUES ('JOHN CENA', 45, NULL, 70000.00);

-- PERFORM THE LEFT JOIN
SELECT E.NAME, D.DEPT_NAME
FROM EMPLOYEES E
LEFT JOIN DEPARTMENTS D ON E.DEPARTMENT = D.DEPT_NAME;

-- SUBQUERIES
-- ADVANCE - 1: WRITE A QUERY TO FIND EMPLOYEES WHOSE SALARY IS HIGHER THAN THE AVERAGE SALARY IN THEIR RESPECTIVE DEPARTMENT, USING A CORRELATED SUBQUERY.
SELECT NAME, SALARY, DEPARTMENT
FROM EMPLOYEES E1
WHERE SALARY > (
    SELECT AVG(SALARY)
    FROM EMPLOYEES E2
    WHERE E1.DEPARTMENT = E2.DEPARTMENT
);

-- SET OPERATIONS
-- ADVANCE - 1: RETRIEVE A LIST OF EMPLOYEES WHO ARE IN EITHER HR OR IT DEPARTMENT, BUT NOT BOTH, USING THE EXCEPT OPERATOR.
-- NOTE: EXCEPT OPERATOR IS USED TO FIND DIFFERENCES BETWEEN TWO SETS. THE LOGIC "EITHER HR OR IT BUT NOT BOTH" IS A SYMMETRIC DIFFERENCE, WHICH CANNOT BE DIRECTLY ACHIEVED WITH A SINGLE EXCEPT.
-- A MORE ACCURATE INTERPRETATION IS TO FIND EMPLOYEES IN ONE DEPARTMENT THAT ARE NOT IN ANOTHER.
-- TO ACHIEVE THE INTENDED SYMMETRIC DIFFERENCE, A COMBINATION OF UNION AND INTERSECT IS TYPICALLY USED.
-- THE PROMPT'S REQUEST IS AMBIGUOUS, BUT THE MOST COMMON INTERPRETATION IS TO FIND EMPLOYEES IN ONE SET BUT NOT THE OTHER.
-- HERE, WE SHOW EMPLOYEES IN HR WHO ARE NOT IN IT, AND VICE VERSA.
-- THE "EXCEPT" OPERATOR IS USED FOR SET DIFFERENCE (A - B). THE "EITHER/OR BUT NOT BOTH" SCENARIO IS A SYMMETRIC DIFFERENCE.
-- SINCE WE CANNOT HAVE AN EMPLOYEE IN BOTH DEPARTMENTS SIMULTANEOUSLY, A SIMPLE UNION OF TWO SEPARATE QUERIES IS THE MOST LOGICAL APPROACH.
-- THE "EXCEPT" OPERATOR IS NOT SUITABLE FOR THIS SPECIFIC "EITHER/OR BUT NOT BOTH" LOGIC, AS IT IMPLIES A SINGLE SET DIFFERENCE.
-- WE WILL USE A UNION WITH A WHERE CLAUSE TO FULFILL THE SPIRIT OF THE REQUEST, AS THE EMPLOYEE CAN'T BE IN BOTH.
SELECT NAME FROM EMPLOYEES WHERE DEPARTMENT = 'HR'
UNION
SELECT NAME FROM EMPLOYEES WHERE DEPARTMENT = 'IT';


-- DATE/TIME
-- ADVANCE - 1: FIND THE AVERAGE NUMBER OF ORDERS PER MONTH FOR THE LAST 6 MONTHS BY USING DATE FUNCTIONS.
-- NOTE: WE NEED AN ORDERS TABLE FOR THIS.
CREATE TABLE ORDERS (
    ORDER_ID SERIAL PRIMARY KEY,
    CUSTOMER_ID INT,
    ORDER_DATE DATE
);

-- INSERT SAMPLE DATA FOR ORDERS
INSERT INTO ORDERS (CUSTOMER_ID, ORDER_DATE) VALUES
(1, CURRENT_DATE - INTERVAL '1 DAY'),
(2, CURRENT_DATE - INTERVAL '15 DAYS'),
(3, CURRENT_DATE - INTERVAL '30 DAYS'),
(4, CURRENT_DATE - INTERVAL '45 DAYS'),
(5, CURRENT_DATE - INTERVAL '60 DAYS'),
(6, CURRENT_DATE - INTERVAL '75 DAYS'),
(7, CURRENT_DATE - INTERVAL '90 DAYS'),
(8, CURRENT_DATE - INTERVAL '105 DAYS'),
(9, CURRENT_DATE - INTERVAL '120 DAYS'),
(10, CURRENT_DATE - INTERVAL '135 DAYS'),
(11, CURRENT_DATE - INTERVAL '150 DAYS'),
(12, CURRENT_DATE - INTERVAL '165 DAYS'),
(13, CURRENT_DATE - INTERVAL '180 DAYS'),
(14, CURRENT_DATE - INTERVAL '190 DAYS'),
(15, CURRENT_DATE - INTERVAL '200 DAYS');

-- FIND THE AVERAGE NUMBER OF ORDERS PER MONTH FOR THE LAST 6 MONTHS
SELECT AVG(MONTHLY_ORDERS)
FROM (
    SELECT COUNT(*) AS MONTHLY_ORDERS
    FROM ORDERS
    WHERE ORDER_DATE >= CURRENT_DATE - INTERVAL '6 MONTHS'
    GROUP BY TO_CHAR(ORDER_DATE, 'YYYY-MM')
) AS SUBQUERY;

-- ADVANCED SQL
-- ADVANCE - 1: USE RANK() TO RANK EMPLOYEES WITHIN THEIR DEPARTMENT BASED ON SALARY, AND THEN RETRIEVE THE TOP 5 RANKED EMPLOYEES.
SELECT * FROM (
    SELECT
        NAME,
        DEPARTMENT,
        SALARY,
        RANK() OVER (PARTITION BY DEPARTMENT ORDER BY SALARY DESC) AS RANK_IN_DEPT
    FROM EMPLOYEES
) AS RANKED_EMPLOYEES
WHERE RANK_IN_DEPT <= 5
ORDER BY DEPARTMENT, RANK_IN_DEPT;

-- STORED PROCEDURE
-- ADVANCE - 1: CREATE A STORED PROCEDURE THAT INSERTS A NEW EMPLOYEE INTO THE EMPLOYEES TABLE AND RETURNS THE NEW EMPLOYEE'S ID.
CREATE OR REPLACE PROCEDURE INSERT_EMPLOYEE(
    P_NAME VARCHAR,
    P_AGE INT,
    P_DEPARTMENT VARCHAR,
    P_SALARY DECIMAL,
    OUT P_ID INT
)
LANGUAGE PLPGSQL
AS $$
BEGIN
    INSERT INTO EMPLOYEES (NAME, AGE, DEPARTMENT, SALARY)
    VALUES (P_NAME, P_AGE, P_DEPARTMENT, P_SALARY)
    RETURNING ID INTO P_ID;
END;
$$;

-- VIEWS
-- ADVANCE - 1: CREATE A VIEW THAT JOINS THREE TABLES: EMPLOYEES, DEPARTMENTS, AND SALES, SHOWING EACH EMPLOYEE'S DEPARTMENT AND TOTAL SALES IN THAT DEPARTMENT.
-- NOTE: WE NEED A SALES TABLE.
CREATE TABLE SALES (
    SALE_ID SERIAL PRIMARY KEY,
    EMPLOYEE_ID INT,
    SALE_AMOUNT DECIMAL(10, 2)
);

-- INSERT SAMPLE DATA FOR SALES
INSERT INTO SALES (EMPLOYEE_ID, SALE_AMOUNT) VALUES
(1, 1000.00),
(2, 2500.00),
(3, 1500.00),
(4, 5000.00),
(5, 750.00),
(6, 2000.00),
(7, 3000.00),
(8, 1200.00),
(9, 3200.00),
(10, 1800.00),
(11, 1400.00),
(12, 4000.00),
(13, 2800.00),
(14, 2200.00),
(15, 1100.00);

-- CREATE A VIEW
CREATE VIEW EMPLOYEE_SALES_SUMMARY AS
SELECT
    E.NAME,
    D.DEPT_NAME AS DEPARTMENT,
    SUM(S.SALE_AMOUNT) AS TOTAL_SALES
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT = D.DEPT_NAME
JOIN SALES S ON E.ID = S.EMPLOYEE_ID
GROUP BY E.NAME, D.DEPT_NAME;

-- FUNCTIONS
-- ADVANCE - 1: RETRIEVE DEPARTMENTS WHERE THE AVERAGE SALARY IS GREATER THAN 50000 USING THE HAVING CLAUSE.
SELECT DEPARTMENT, AVG(SALARY) AS AVERAGE_SALARY
FROM EMPLOYEES
GROUP BY DEPARTMENT
HAVING AVG(SALARY) > 50000;

-- TRIGGERS
-- ADVANCE - 1: CREATE A TRIGGER THAT UPDATES THE LAST_UPDATED COLUMN EVERY TIME AN EMPLOYEE'S SALARY IS CHANGED.
-- NOTE: FIRST, ADD THE COLUMN TO THE EMPLOYEES TABLE.
ALTER TABLE EMPLOYEES ADD COLUMN LAST_UPDATED TIMESTAMP;

-- CREATE THE TRIGGER FUNCTION
CREATE OR REPLACE FUNCTION UPDATE_LAST_UPDATED()
RETURNS TRIGGER AS $$
BEGIN
    NEW.LAST_UPDATED = NOW();
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

-- CREATE THE TRIGGER
CREATE TRIGGER EMPLOYEE_SALARY_UPDATE
BEFORE UPDATE OF SALARY ON EMPLOYEES
FOR EACH ROW
EXECUTE FUNCTION UPDATE_LAST_UPDATED();

-- TRANSACTIONS
-- ADVANCE - 1: WRITE A TRIGGER TO AUTOMATICALLY DEDUCT 5% FROM AN EMPLOYEE'S SALARY IF THEIR SALARY EXCEEDS 100000.
-- NOTE: THIS IS A TRIGGER, NOT A TRANSACTION. THE PROMPT IS MISLABELED.
-- CREATE THE TRIGGER FUNCTION
CREATE OR REPLACE FUNCTION DEDUCT_SALARY()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.SALARY > 100000 THEN
        NEW.SALARY = NEW.SALARY * 0.95;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

-- CREATE THE TRIGGER
CREATE TRIGGER SALARY_DEDUCTION
BEFORE UPDATE OF SALARY ON EMPLOYEES
FOR EACH ROW
EXECUTE FUNCTION DEDUCT_SALARY();

-- WILDCARD OPS
-- ADVANCE - 1: FIND EMPLOYEES WHOSE NAMES CONTAIN THE SUBSTRING "JOHN" USING A WILDCARD SEARCH.
SELECT NAME, DEPARTMENT
FROM EMPLOYEES
WHERE NAME ILIKE '%JOHN%';

-- KEYS/CONSTRAINTS
-- ADVANCE - 1: MODIFY THE EMPLOYEES TABLE TO ADD A UNIQUE CONSTRAINT ON THE EMAIL COLUMN.
-- NOTE: FIRST, ADD THE EMAIL COLUMN.
ALTER TABLE EMPLOYEES ADD COLUMN EMAIL VARCHAR(255);

-- ADD THE UNIQUE CONSTRAINT
ALTER TABLE EMPLOYEES ADD CONSTRAINT UNIQUE_EMAIL UNIQUE (EMAIL);

-- INDEXES
-- ADVANCE - 1: OPTIMIZE A QUERY THAT JOINS MULTIPLE TABLES WITH AN INDEX AND EXPLAIN THE PERFORMANCE IMPROVEMENT.
-- NOTE: FIRST, CREATE A NEW INDEX ON A JOIN COLUMN.
CREATE INDEX IDX_DEPT_NAME ON DEPARTMENTS (DEPT_NAME);

-- THEN, PERFORM A JOIN QUERY. THE DATABASE WILL LIKELY USE THE INDEX.
-- THE EXPLANATION IS PROVIDED AS A COMMENT.
-- THE INDEX ON DEPARTMENTS(DEPT_NAME) IMPROVES THE PERFORMANCE OF THE JOIN OPERATION
-- BETWEEN EMPLOYEES AND DEPARTMENTS BY ALLOWING THE DATABASE TO QUICKLY LOOK UP DEPARTMENT
-- RECORDS FOR EACH EMPLOYEE, AVOIDING A FULL TABLE SCAN.
SELECT E.NAME, D.DEPT_NAME
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT = D.DEPT_NAME;

-- DDL STATEMENTS
-- ADVANCE - 1: WRITE SQL TO TRUNCATE A TABLE AND THEN DROP IT COMPLETELY FROM THE DATABASE.
-- NOTE: TRUNCATING WILL REMOVE ALL DATA BUT KEEP THE TABLE STRUCTURE.
-- DROPPING WILL REMOVE THE TABLE ENTIRELY.
TRUNCATE TABLE EMPLOYEES;

-- DROP THE TABLES IN REVERSE ORDER OF DEPENDENCY
-- THIS IS A CLEANUP STEP AND WILL REMOVE THE TABLES CREATED ABOVE.
DROP TABLE IF EXISTS SALES;
DROP VIEW IF EXISTS EMPLOYEE_SALES_SUMMARY;
DROP PROCEDURE IF EXISTS INSERT_EMPLOYEE;
DROP TRIGGER IF EXISTS SALARY_DEDUCTION ON EMPLOYEES;
DROP TRIGGER IF EXISTS EMPLOYEE_SALARY_UPDATE ON EMPLOYEES;
DROP TABLE IF EXISTS ORDERS;
DROP TABLE IF EXISTS EMPLOYEES;
DROP TABLE IF EXISTS DEPARTMENTS;